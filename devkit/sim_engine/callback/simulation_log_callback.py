import logging
import pathlib
from concurrent.futures import Future
from typing import List, Optional, Union

from devkit.scenario_builder.abstract_scenario import AbstractScenario
from devkit.sim_engine.callback.abstract_callback import AbstractCallback
from devkit.sim_engine.history.simulation_history import SimulationHistory
from devkit.sim_engine.history.simulation_history import SimulationHistorySample
from devkit.sim_engine.planning.planner.abstract_planner import AbstractPlanner
from devkit.sim_engine.log_api.simulation_log import SimulationLog
from devkit.sim_engine.environment_manager.simulation_setup import SimulationSetup
from devkit.common.trajectory.abstract_trajectory import AbstractTrajectory
from devkit.utils.multithreading.worker_pool import Task, WorkerPool

logger = logging.getLogger(__name__)


def _save_log_to_file(file_name: pathlib.Path, scenario: AbstractScenario, planner: AbstractPlanner, history: SimulationHistory) -> None:
    """
    Create SimulationLog and save it to disk.
    :param file_name: to write to.
    :param scenario: to store in the log.
    :param planner: to store in the log.
    :param history: to store in the log.
    """
    # 通过 SimulationLog 保存仿真过程的信息
    simulation_log = SimulationLog(file_path=file_name, scenario=scenario, planner=planner, simulation_history=history)
    simulation_log.save_to_file()

    # todo 通过 原先的json 保存仿真过程的信息


class SimulationLogCallback(AbstractCallback):
    """
    Callback for simulation logging/object serialization to disk.
    """

    def __init__(
        self,
        output_directory: Union[str, pathlib.Path],
        simulation_log_dir: Union[str, pathlib.Path],
        serialization_type: str,
        worker_pool: Optional[WorkerPool] = None,
    ):
        """
        Construct simulation log callback.
        :param output_directory: where scenes should be serialized.
        :param simulation_log_dir: Folder where to save simulation logs.
        :param serialization_type: A way to serialize output, options: ["json", "pickle", "msgpack"].
        """
        # 允许的序列化格式
        available_formats = ["pickle", "msgpack"]
        if serialization_type not in available_formats:
            raise ValueError(
                "The simulation log callback will not store files anywhere!"
                f"Choose at least one format from {available_formats} instead of {serialization_type}!"
            )

        # 最终的输出目录 = 基本输出目录 + 传入的日志目录
        self._output_directory = pathlib.Path(output_directory) / simulation_log_dir

        self._serialization_type = serialization_type
        if serialization_type == "pickle":
            file_suffix = ".pkl.xz"  # pickle 压缩格式的文件后缀
        elif serialization_type == "msgpack":
            file_suffix = ".msgpack.xz"  # msgpack 压缩格式的文件后缀
        else:
            raise ValueError(f"Unknown option: {serialization_type}")
        self._file_suffix = file_suffix

        self._pool = worker_pool  # 用于异步存储的工作池(如有)
        self._futures: List[Future[None]] = []  # 用于保存所有提交的异步任务 Future

    @property
    def futures(self) -> List[Future[None]]:
        """
        Returns a list of futures, eg. for the main process to block on.
        :return: any futures generated by running any part of the callback asynchronously.
        """
        return self._futures

    def on_initialization_start(self, setup: SimulationSetup, planner: AbstractPlanner) -> None:
        """
        Create directory at initialization
        :param setup: simulation setup
        :param planner: planner before initialization
        """
        # 获取当前场景对应的目录，用于存放序列化结果
        # '/tmp/tmpw5d1iy4l/planner_demo/planner_demo_2/simulation_log/SimplePlanner/intersection_mixd/Scenario-dapai_intersection_1_3_4.json/dapai_intersection_1_3_4'
        scenario_directory = self._get_scenario_folder(planner.name(), setup.scenario)
        scenario_directory.mkdir(exist_ok=True, parents=True)

    def on_initialization_end(self, setup: SimulationSetup, planner: AbstractPlanner) -> None:
        """Inherited, see superclass."""
        pass

    def on_step_start(self, setup: SimulationSetup, planner: AbstractPlanner) -> None:
        """Inherited, see superclass."""
        pass

    def on_step_end(self, setup: SimulationSetup, planner: AbstractPlanner, sample: SimulationHistorySample) -> None:
        """Inherited, see superclass."""
        pass

    def on_planner_start(self, setup: SimulationSetup, planner: AbstractPlanner) -> None:
        """Inherited, see superclass."""
        pass

    def on_planner_end(self, setup: SimulationSetup, planner: AbstractPlanner, trajectory: AbstractTrajectory) -> None:
        """Inherited, see superclass."""
        pass

    def on_simulation_start(self, setup: SimulationSetup) -> None:
        """Inherited, see superclass."""
        pass

    def on_simulation_end(self, setup: SimulationSetup, planner: AbstractPlanner, history: SimulationHistory) -> None:
        """
        On reached_end validate that all steps were correctly serialized.
        :param setup: simulation setup.
        :param planner: planner when simulation ends.
        :param history: resulting from simulation.
        """
        logger.info("#log# Record simulation log...")
        number_of_scenes = len(history)  # 仿真历史中的场景步数
        if number_of_scenes == 0:
            raise RuntimeError("Number of scenes has to be greater than 0")

        # Create directory
        scenario_directory = self._get_scenario_folder(planner.name(), setup.scenario)

        # 组合完整文件路径(场景名称 + 文件后缀)
        scenario = setup.scenario
        file_name = scenario_directory / (scenario.scenario_name + self._file_suffix)

        if self._pool is not None:
            self._futures = []
            # 使用多线程/进程池来异步保存日志文件
            self._futures.append(
                self._pool.submit(
                    Task(_save_log_to_file, num_cpus=1, num_gpus=0),  # 封装要执行的任务
                    file_name,
                    scenario,
                    planner,
                    history,
                )
            )
        else:
            # 如果没有工作池，则同步方式直接保存到文件 #! 记录仿真信息
            _save_log_to_file(file_name, scenario, planner, history)
        logger.info("#log# Record simulation log END!")

    def _get_scenario_folder(self, planner_name: str, scenario: AbstractScenario) -> pathlib.Path:
        """
        Compute scenario folder directory where all files will be stored.
        :param planner_name: planner name.
        :param scenario: for which to compute directory name.
        :return directory path.
        """
        # 多层级目录结构: output_dir / planner_name / scenario_type / log_name / scenario_name
        # return self._output_directory / planner_name / scenario.scenario_type / scenario.log_name / scenario.scenario_name  # type: ignore
        return self._output_directory / planner_name / scenario.scenario_type / scenario.scenario_name  # type: ignore
